/*
 * This file is part of UltimateCore, licensed under the MIT License (MIT).
 *
 * Copyright (c) Bammerbom
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package bammerbom.ultimatecore.sponge.utils;

import bammerbom.ultimatecore.sponge.UltimateCore;
import bammerbom.ultimatecore.sponge.config.GeneralConfig;
import org.spongepowered.api.Sponge;
import org.spongepowered.api.asset.Asset;
import org.spongepowered.api.command.CommandSource;
import org.spongepowered.api.text.Text;
import org.spongepowered.api.text.serializer.TextParseException;
import org.spongepowered.api.text.serializer.TextSerializers;

import javax.annotation.Nullable;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public class Messages {

    private static Map<String, String> EN_US = new HashMap<>();
    private static Map<String, String> custom = new HashMap<>();

    public static void reloadMessages() {
        reloadEnglishMessages();
        reloadCustomMessages();
    }

    public static void reloadEnglishMessages() {
        try {
            EN_US = loadFromFile("EN_US");
        } catch (IOException e) {
            log(Text.of("Failed to load english messages file."));
            e.printStackTrace();
        }
    }

    public static void reloadCustomMessages() {
        String lang = GeneralConfig.get().getNode("language", "language").getString();
        if (lang.equals("EN_US")) {
            return;
        }
        try {
            custom = loadFromFile(lang);
        } catch (IOException e) {
            log(Text.of("Failed to load " + lang + " messages file."));
            e.printStackTrace();
        }
    }

    /**
     * Retrieves a Map of all keys and values of a language file
     *
     * @param lang The name of the language file, for example `english` for the file 'EN_US.properties'
     * @return A map of all keys and values
     * @throws IOException When the file was not found, was invalid, or failed to load in any other way
     */
    private static Map<String, String> loadFromFile(String lang) throws IOException {
        Asset asset = Sponge.getAssetManager().getAsset(UltimateCore.get(), "language/" + lang + ".properties").orElse(null);
        File file = new File(UltimateCore.get().getConfigFolder().toUri().getPath() + "/language/", lang + ".properties");

        if (!file.exists()) {
            file.getParentFile().mkdirs();
            asset.copyToFile(file.toPath());
        }
        //Properties of the file in the dir
        Properties prop = new Properties();
        InputStream stream = new FileInputStream(file);
        prop.load(stream);
        Map<String, String> map = toMap(prop);
        stream.close();

        //Only check for missing keys if non-custom language file
        if (asset != null) {
            //Properties of the file in the jar
            Properties lprop = new Properties();
            InputStream lstream = asset.getUrl().openStream();
            lprop.load(lstream);
            Map<String, String> lmap = toMap(lprop);
            lstream.close();

            //Copy missing keys
            boolean missing = false;
            for (String key : lmap.keySet()) {
                if (!map.containsKey(key)) {
                    map.put(key, lmap.get(key));
                    prop.put(key, lmap.get(key));
                    missing = true;
                    Messages.log("Added missing key " + key + "=" + lmap.get(key) + " to language file " + lang);
                }
            }
            if (missing) {
                FileOutputStream ostream = new FileOutputStream(file);
                prop.store(ostream, "UltimateCore language file - " + lang);
                ostream.close();
            }
        }

        return map;
    }

    private static Map<String, String> toMap(Properties prop) {
        Map<String, String> map = new HashMap<>();
        for (Object key : prop.keySet()) {
            map.put(key.toString(), prop.getProperty(key.toString()));
        }
        return map;
    }

    /**
     * Get a string with all available formatting, including click and hover actions.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The ampersand-formatted message
     */
    public static Text getFormatted(@Nullable CommandSource p, String key, Object... vars) {
        String raw = get(p, key, vars);
        Text text;
        try {
            text = TextSerializers.JSON.deserialize(raw);
        } catch (TextParseException ex) {
            try {
                text = TextSerializers.TEXT_XML.deserialize(raw);
            } catch (TextParseException ex2) {
                try {
                    text = TextSerializers.FORMATTING_CODE.deserialize(raw);
                } catch (Exception ex3) {
                    text = TextSerializers.PLAIN.deserialize(raw);
                }
            }
        }

        String first = null;
        for (Object var : vars) {
            if (first == null) {
                first = var.toString();
            } else {
                if (var instanceof Text) {
                    text = TextUtil.replace(text, first, (Text) var);
                }
                //Else will be at get()
                first = null;
            }
        }

        //Replace default variables
        //This will not override any other variables because they have been replaced by now
        text = VariableUtil.replaceVariables(text, p);

        return text;
    }

    /**
     * Get a string with all available formatting, including click and hover actions.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The ampersand-formatted message
     */
    public static Text getFormatted(String key, Object... vars) {
        return getFormatted(null, key, vars);
    }

    /**
     * Get a string which is formatted with Ampersands.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The ampersand-formatted message
     */
    public static String getColored(@Nullable CommandSource p, String key, Object... vars) {
        return TextSerializers.FORMATTING_CODE.serialize(getFormatted(p, key, vars));
    }

    /**
     * Get a string which is formatted with Ampersands.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The ampersand-formatted message
     */
    public static String getColored(String key, Object... vars) {
        return getColored(null, key, vars);
    }

    /**
     * Get the pure text without any formatting from the language file.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The plain-text message
     */
    public static String getPlain(@Nullable CommandSource p, String key, Object... vars) {
        return getFormatted(p, key, vars).toPlain();
    }

    /**
     * Get the pure text without any formatting from the language file.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The plain-text message
     */
    public static String getPlain(String key, Object... vars) {
        return getPlain(null, key, vars);
    }

    /**
     * Get a raw message from the language file.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The raw message, or null when not found
     */
    public static String get(@Nullable CommandSource p, String key, Object... vars) {
        String raw;
        if (custom.containsKey(key)) {
            raw = custom.get(key);
        } else if (EN_US.containsKey(key)) {
            raw = EN_US.get(key);
        } else {
            return null;
        }
        String first = null;
        for (Object var : vars) {
            if (first == null) {
                first = var.toString();
            } else {
                if (var instanceof Text) {
                    //Will replaced later if needed
                } else {
                    raw = raw.replace(first, var.toString());
                }
                first = null;
            }
        }
        return raw;
    }

    /**
     * Get a raw message from the language file.
     *
     * @param key  The key of the message to get
     * @param vars The variables to replace. When {Banana, Apple} is provided Banana will be replaced with Apple
     * @return The raw message, or null when not found
     */
    public static String get(String key, Object... vars) {
        return get(null, key, vars);
    }

    /**
     * Print the message to the console, with the UC prefix in front of it.
     *
     * @param message The message to print
     */
    public static void log(Object message) {
        Text logo = Text.of("[UC] ");
        if (message == null) {
            log("null");
            return;
        }
        Sponge.getServer().getConsole().sendMessage(logo.toBuilder().append(Text.of(message)).build());
    }

    /**
     * Does exactly the same as .log(), but can be found using ctrl + f so I can remove them later
     */
    public static void debug(Object message) {
        log(message);
    }

    /**
     * Convert a String to a Text object
     */
    public static Text toText(String raw) {
        try {
            return TextSerializers.JSON.deserialize(raw);
        } catch (TextParseException ex) {
            try {
                return TextSerializers.TEXT_XML.deserialize(raw);
            } catch (TextParseException ex2) {
                try {
                    return TextSerializers.FORMATTING_CODE.deserialize(raw);
                } catch (Exception ex3) {
                    return Text.of(raw);
                }
            }
        }
    }
}
